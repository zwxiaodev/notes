在多线程的世界里，一共有三个问题：原子性问题、可见性问题、有序性问题。整个java并发体系也是围绕着如何解决这三个问题来设计的。
volatile关键字也不例外，我们都知道它解决了可见性和有序性，但是不能保证原子性。

一、有序性
1、有序性案例
有序性指的是：程序执行的顺序按照代码的先后顺序执行。我们可以先看一个被列举了一万次的代码：
int i = 0;
boolean flag = false;
i = 1;			  //语句1
flag = true;	//语句2
按照我们自己常规的想法，顺序应该从上往下依次执行，但是真实情况是：jvm会在真正执行这段代码的时候进行优化，发生指令的重排序。因此不能保证语句1一定在语句2先执行。

2、数据依赖性
上面的例子，你还会发现这样一个特点，就算是发生了指令的重排序，但是最后的结果总是正确的。我们再举一个例子：
int a = 10;	//语句1
int r= 2;	//语句2
a = a+3;	//语句3
r = a*a;	//语句4
这种情况会发生指令重排序吗？显然不会，原因是处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令2必须用到指令1的结果，那么处理器一定保证指令1在指令2执行。

3、多线程问题
这种数据的依赖性在单线程环境下一点问题没有，因为总能保证数据的正确，但是在多线程环境下就会出现错误。我们再举一个例子：
class Test{
	int a=0;
	boolean flag = false;
	public void do1(){
		a = 1;			//1
		flag = true;	//2
	}
	
	public do2(){
		if(flag){		//3
			int i = a*a;//4
		}
	}
}
上面的这段代码由于语句1和语句2没有数据依赖性，因此会发生指令重排。do2只要看到flag为true，就执行。因此可能的顺序是：
（1）语句1先于语句2：语句2->语句3->语句1->语句4。这时候的结果i=1。
（1）语句2先于语句1：语句2->语句3->语句4->语句1。这时候的结果i=0。
现在我们可以看到在多线程环境下如果发生了指令的重排序，会对结果造成影响。
上面一开始提到过，volatile可以保证有序性，也就是可以防止指令重排序。那么它是如何解决的呢？这就是内存屏障。因此我们从内存屏障讲起。

二、内存屏障
1、什么是内存屏障
内存屏障其实就是一个CPU指令，在硬件层面上来说可以扥为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。
java 编译器禁止处理器重排序是通过在生成指令序列的适当位置会插入内存屏障（重排序时不能把后面的指令重排序到内存屏障之前的位置）指令来实现的。
主要有两个作用：
（1）阻止屏障两侧的指令重排序；
（2）强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。
在JVM层面上来说作用与上面的一样，但是种类可以分为四种：
loadload：load1 loadload load2；       //保证load1的读操作先于load2的读操作
storestore：store1 storestore store2； //保证store1的写操作先于store2，并且刷新到主内存
loadstore：load1 loadstore store2；    //保证load1的读操作结束先于store2的写操作
storeload：store1 storeload load2；    //保证sotre1的写操作已刷新到主内存之后再执行load2的读操作

2、volatile如何保证有序性？
首先一个变量被volatile关键字修饰之后有两个作用：
（1）对于写操作：对变量更改完之后，要立刻写回到主存中。
（2）对于读操作：对变量读取的时候，要从主存中读，而不是缓存。

OK，一句话说完就是内存屏障保证了volatile的有序性。
