线程学习笔记：
1、synchronized：重量级锁，锁的是对象（堆内存中的内存区域，不是对象变量的引用），要避免代码中改变锁对象失效；同时保证原子性和可见性
2、volatile：修饰的变量是用于线程间可见性（无锁同步），只能保证可见，但不保证原子性（数据一致性）,无法替代synchronized
3、原子性：同步块里的代码不能被其他线程打断
4、synchronized重入锁：synchronized同步块里再调用同一个对象的synchronized方法，或则子类的synchronized方法调用父类的synchronized方法是可以的
5、一个线程已经在执行一个对象的synchronized代码时，其他线程也能再调用该对象的非synchronized方法（只有synchronized方法才需要获取对象的锁，非synchronized方法不需要获取锁）
6、效率高->低：Atomic*.java(原子类) > volatile > synchronized
7、原子类的方法都是原子性的，但是调用多个原子方法之间，并不是原子操作，也有可能被打断；原子方法使用很底层的方法来实现，效率高
8、JMM:A、B线程都要用到同一个变量，java默认是A线程中会保留一份copy，这样如果线程B修改了变量值，则A线程是未必知道；从主内存中拷贝变量到线程私有的内存，不会总是去同步主内存到私有内存
9、synchronized代码里跑出异常，java默认是会释放锁的；不想释放锁则需要try catch处理，否则其他线程可能获取到锁，执行已经错误的数据
10、并行：多个线程同时在多核cpu同时执行；并发：同一个cpu里多个线程，根据时间片轮循线程来实现；切换线程上下文，切换时要保存当前线程的上下文信息（程序计数器等）
11、不要以字符串常量作为锁定对象，其实是锁的同一个对象；jetty出现一个很隐蔽的bug就是因为锁定了同一个字符串
12、lambda表达式（蓝不大）：java8开始引入的，适用场景：1、接口或父类 2、接口或父类只有一个方法；比如：线程的匿名类，其实就是简写代码而已
13、当多线程不涉及同步，只是涉及线程通信的时候，用synchronized+wait/notify/notifyall就显得太重了，这只应该考虑：CountDownLatch/CyclicBarrier/Semaphore
14、wait、notify/notifyall:都是锁对象调用的方法，因此必定是线程先锁定了该对象，才能执行该对象的这些方法调用；
15、wait会释放对象锁，进入等待状态；其他方法不会释放锁；java中线程没有唤醒执行线程的方法，notify都是唤醒需要获取该锁对象的线程，参与竞争锁，cpu线程调度器来决定哪个线程执行；
notifyall是唤醒所有等待状态的线程
16、CountDownLatch：同步计数器，当计数器数值减为0时，所有受其影响而等待的线程将会被激活；代替wait/notify/notifyall来进行线程间的通信，还可以指定等待时间使用await、countdown方法代替wait/notify
